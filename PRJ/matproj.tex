\documentclass[11pt,a4paper,oneside]{report}
\usepackage{moreverb}
\begin{document}
\title{SymPy, A Python Library for Symbolic Mathematics}
\author{Jason Hsu, Keyan Kousha, Damian Rooney}
\date{Fall 2011}
\maketitle
\section*{Introduction}
Manipulating mathematical equations in symbolic form is rarely a built-in general programming language (GPL) feature. It's certainly not in today's popular programming languages. For mathematicians, this means learning a new domain specific language (DSL) to conduct such work, often barring its functionality from use in a more general context. Where integration between a DSL and a GPL is possible, it is often complicated, or ugly at best; in addition, studying or modifying the code base in these frequently proprietary languages isn't allowed; and features normally found in a GPL are an afterthought and require learning additional new syntax. Beyond the inconvenience, most popular languages in the symbolic math domain also have prohibitive costs (e.g. MatLab, Mathematica, etc.). It would be nice then to have symbolic math be a library to a GPL, written in a GPL, licenced like a GPL, with an implementation as transparent as a GPL's implementation. This is where SymPy, an open source Python library for symbolic math, enters.
\section*{Features}
SymPy is both written and interfaced with entirely in Python (although, according to their webpage, in the future they will supply a C-written core as an option). It's feature list reads as you would expect a computer algebra system's (CAS) feature list to read. It provides things as basic as algebraic simplification and expansion, complex numbers, differentiation, integration, algebraic and differential equation solvers, etc. It also contains modules for algebraic geometry, arbitrary precision floating point arithmetic, statistics, matrices, and quantum physics, among others. Printing, and plotting in both two and three dimensions, is supported as well. SymPy furnishes the user with all the standard fare of a paid CAS, but for free in a well-known, non-proprietary language for easy extensibility and modification.\\\\
 SymPy's features have even found their way into a more elaborate open source CAS, Sage, which is similarly interfaced with via Python (however, unlike SymPy, Sage has components written in several other languages). According to Sage's Wikipedia entry, SymPy's library is used in it's implementation of calculus tools.
 \section*{Why Python? Wow, Python!}
 BS BS BS
 Exec in abc.py code generation, etc., etc
 \section*{The SymPy Core Package}
Naturally, the base classes for SymPy are fairly complex. But that affords an architecture that is straightforward yet powerful. Scratching a few surfaces is enough to get started using and extending SymPy.\\\\
The base class of all objects in SymPy, resident to the core package, is the Basic class. The Basic class encapsulates all functionality "basic" to all symbols. This includes defining things like comparisons between generic symbol trees, pattern queries, etc.; providing a uniform interface for accessing symbol object hashes, symbol atoms in expressions, and type info (like communitivity and positivity); and, insuring all symbols are immutable (more on that later). The Basic class is important because it's the parent to the Symbol class, which is the primary construct users interact with.
\subsection*{\small Symbol Objects}
To create a symbol in SymPy, one simply pulls up Python in interactive mode, imports the Symbol class from sympy and begins creating symbols as in the following:
\begin{verbatim}
>>> from sympy import Symbol
>>> a = Symbol('a')
>>> b = Symbol('b')
>>> c = a*b
>>> c
a*b
\end{verbatim}
What's shown above is pretty straightforward, but it demonstrates the simplicity of creating symbols then nesting them in an expression object of type Mul. Mul itself behaves much like a Symbol because it is similarly a descendant of Basic.
\begin{verbatim}
 |  Method resolution order:
 |      Mul
 |      sympy.core.operations.AssocOp
 |      sympy.core.expr.Expr
 |      sympy.core.basic.Basic
 |      sympy.core.assumptions.AssumeMeths
 |      sympy.core.evalf.EvalfMixin
 |      __builtin__.object
\end{verbatim}
This occurs because Symbol descends from a class that overloads the asterisk, and all other arithmetic operators, to deal with Symbols (synonymously in the architecture, Atoms and Exprs). Symbolic compositions like this extend to any class derived from Basic, so to enable users to define their own functions. A few more complicated uses/compositions are shown below, but many more exist and behave just as intuitively.
\begin{verbatim}
>>> from sympy import *
>>> from sympy.abc import x, a, b, c #creates Symbols for chars (more on this later)
>>> integrate(x**2 * exp(x) * cos(x), x)
x**2*exp(x)*sin(x)/2 + x**2*exp(x)*cos(x)/2 - x*exp(x)*sin(x) + exp(x)*sin(x)/2 
- exp(x)*cos(x)/2
>>> (pi*x**2 + x/3).evalf()
3.14159265358979*x**2 + 0.333333333333333*x
>>> x = Point(0,0)
>>> y = Point(c,0)
>>> z = Point(a,b)
>>> t = Triangle(x,y,z)
>>> t.area
b*c/2
>>> x = Symbol('x') #define x to be a symbol again
>>> limit(1/x, x, oo)
0
\end{verbatim}
The above should suffice for a top level understanding, but much else that exists in the core facilitates the movement, efficiency (there's a Symbol cache!), and representation of Symbols within SymPy.
\section*{Python in sympy.core}
Python is used in some interesting ways to acheive the core's functionality. We'll dicuss a small number of them briefly.
\subsection*{\small \_\_slots\_\_}
 One interesting way is keeping Basic and derived classes immutable and lightweight. This is done by interfering in the instance creation process.
\begin{verbatim}
    __slots__ = ['_mhash',              # hash value
                 '_args',               # arguments
                 '_assume_type_keys',   # assumptions typeinfo keys
                ]
\end{verbatim}
The above creates an immutable class by preventing the creation of the normal python dictionary, which would be extendable by users and take up unnecessary space. (All symbols in SymPy are also expression immutable, but this is kept by convention: always returning an "expression immutable" copy on mutate operations.)
\subsection*{\small \_\_new\_\_()}
Something else seen in this class Basic, and the majority of core classes, is the definition of \_\_new\_\_() which returns an instance of the class. Unlike \_\_init\_\_(), \_\_new\_\_() allows customization of the instance creation itself, not just initialization. One example of this is used to cache Symbol objects. The following is a return statement from Symbol's \_\_new\_\_().
\begin{verbatim}
return Symbol.__xnew_cached_(cls, name, commutative, **assumptions)
\end{verbatim}
This call returns a cached Symbol if it exists or creates a new Symbol should it not already exist, avoiding the recurrence of allocation. Singletons in SymPy are another instance of the use of \_\_new\_\_() which is used to check if a singleton is in the singleton registry.
\subsection*{\small Decorators}
Caches and registries aren't unique to Python; however, the way this is implemented in SymPy using Python is pretty attractive. In the case of caching, SymPy uses decorators to wrap function calls, the results of which are cached. In the Symbol class, this is done in the old style (closure syntax), but other occurences of the @cacheit decorator use this new style. 
\begin{verbatimtab}
# the occurence in sympy.core.symbol
__xnew_cached_ = staticmethod(cacheit(__new_stage2__))
# in sympy.core.basic
@cacheit
def _subs_old_new(self, old, new):
	...
\end{verbatimtab}
A common Python idiom is then used within @cacheit to ensure that this "wrapper" is transparent to the user of the function.
\begin{verbatimtab}
def __cacheit(func):
	...
	@wraps(func)
    def wrapper(*args, **kw_args):
    	...
    return wrapper
\end{verbatimtab}
This allows the interpreter to maintain the special attributes of \_subs\_old\_new, and other decorated functions, when the function being called is actually its wrapper (special attributes here are those such as \_\_name\_\_ and \_\_doc\_\_, which are important for introspection).
\subsection*{\small Metaclasses}
The last example that we'll cover on Python in SymPy, although are many, many more engaging uses, is metaclasses. Much like \_\_new\_\_ in Python intercepts instance creation of an object, metaclasses intercept creation of class objects. Everything in Python is an object, even ints, and so are classes.\\\\
 The class keyword internally creates an object for the specified, and this is what metaclasses interfere with: how this class object is created. To interfere in this way, one simply defines the \_\_metaclass\_\_ variable in the class one wants to intevene in, and Python does the rest, calling the metaclass before the class object is created with the information about the original class object. The Basic class in sympy.core uses such a meta class. It's defined as simply as the following.
\begin{verbatim}
__metaclass__ = BasicMeta
\end{verbatim}
Being the base class for all symbol objects, Basic has many duties. One of these duties is maintaining assumptions about symbols and consequences derived from such assumptions. Metaclasses are inherited when subclassing, so as far as we can tell (admittedly, BasicMeta uses a lot of magic), BasicMeta creates default assumptions and derives consequences of premises that a class derived from Basic might define. This is the common use of metaclasses, often occuring in Python API's: abstraction of low-level class maintaince or representation for class designers.\\\\
As said, this is only a survey of a few Python tools used in SymPy's core package. But it should be clear how much of Python is being leveraged to do very cool things in its lower levels.
\end{document}